<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ meeting.title }} - Edumi Meet</title>
    {% load static %}
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'css/base.css' %}">
    <link rel="stylesheet" href="{% static 'css/meeting-room.css' %}">
</head>
<body class="meeting-body">
    <div class="meet-container">
        <!-- Top Bar -->
        <div class="meet-topbar">
            <div class="meet-info">
                <h3>{{ meeting.title }}</h3>
                <span class="meet-code">{{ meeting.meeting_code }}</span>
            </div>
            <div class="meet-timer" id="meetTimer">00:00</div>
        </div>
        
        <!-- Video Grid -->
        <div class="meet-main">
            <div class="video-grid-container" id="videoGridContainer">
                <!-- Local video will be added here -->
            </div>
            
            <!-- Sidebar -->
            <div class="meet-sidebar" id="meetSidebar" style="display: none;">
                <div class="sidebar-header">
                    <div class="sidebar-tabs">
                        <button class="sidebar-tab active" onclick="switchSidebarTab('people')">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                            <span>People</span>
                        </button>
                        <button class="sidebar-tab" onclick="switchSidebarTab('chat')">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                            <span>Chat</span>
                        </button>
                    </div>
                    <button class="close-sidebar" onclick="toggleSidebar()">âœ•</button>
                </div>
                
                <div class="sidebar-content">
                    <!-- People Tab -->
                    <div class="sidebar-panel active" id="peoplePanel">
                        <div class="participants-count">
                            <span id="participantCount">1</span> in call
                        </div>
                        <div class="participants-list" id="participantsList">
                            <div class="participant-item">
                                <div class="participant-avatar">
                                    <img src="https://ui-avatars.com/api/?name={{ user.username }}&background=1877f2&color=fff" alt="{{ user.username }}">
                                </div>
                                <div class="participant-info">
                                    <div class="participant-name">{{ user.username }} (You)</div>
                                    {% if is_host %}<span class="host-label">Host</span>{% endif %}
                                </div>
                                <div class="participant-status" id="localStatus">
                                    <svg id="localMicStatus" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                                    <svg id="localCamStatus" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Chat Tab -->
                    <div class="sidebar-panel" id="chatPanel">
                        <div class="chat-messages" id="chatMessages"></div>
                        <div class="chat-input-box">
                            <input type="text" id="chatInput" placeholder="Send a message to everyone" />
                            <button onclick="sendChatMessage()" class="send-btn">Send</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Floating Controls -->
        <div class="meet-controls">
            <button class="control-button" id="micBtn" onclick="toggleMic()" title="Microphone">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
            </button>
            
            <button class="control-button" id="camBtn" onclick="toggleCamera()" title="Camera">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>
            </button>
            
            {% if meeting.allow_screen_share %}
            <button class="control-button" id="screenBtn" onclick="toggleScreenShare()" title="Share screen">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
            </button>
            {% endif %}
            
            <div class="control-divider"></div>
            
            <button class="control-button" id="peopleBtn" onclick="openSidebar('people')" title="Participants">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
            </button>
            
            <button class="control-button" id="chatBtn" onclick="openSidebar('chat')" title="Chat">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                <span class="notification-badge" id="chatBadge" style="display: none;">0</span>
            </button>
            
            <div class="control-divider"></div>
            
            <button class="control-button danger" onclick="leaveMeeting()" title="Leave call">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>
            </button>
        </div>
    </div>

<script>
const meetingId = {{ meeting.id }};
const meetingCode = "{{ meeting.meeting_code }}";
const currentUserId = {{ user.id }};
const currentUsername = "{{ user.username }}";
const isHost = {% if is_host %}true{% else %}false{% endif %};

// WebSocket connection
const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
const wsUrl = `${protocol}//${window.location.host}/ws/meeting/${meetingCode}/`;
let ws = null;

// WebRTC configuration
const rtcConfig = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }
    ],
    iceCandidatePoolSize: 10,
    bundlePolicy: 'max-bundle',
    rtcpMuxPolicy: 'require',
    iceTransportPolicy: 'all'
};

// State
let localStream = null;
let screenStream = null;
let peerConnections = {};
let participants = {};
let isMicOn = true;
let isCameraOn = true;
let isScreenSharing = false;
let screenSharingUserId = null;
let unreadMessages = 0;

// Initialize
async function init() {
    try {
        // Get user media with lower quality for better performance
        localStream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 480, max: 640 },
                height: { ideal: 360, max: 480 },
                frameRate: { ideal: 15, max: 24 },
                facingMode: 'user'
            },
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                sampleRate: 16000
            }
        });
        
        // Add local video
        addVideoElement(currentUserId, currentUsername, localStream, true);
        
        // Connect WebSocket
        connectWebSocket();
        
        // Start timer
        startTimer();
        
    } catch (error) {
        console.error('Error accessing media:', error);
        alert('Could not access camera/microphone. Please check permissions.');
    }
}

function connectWebSocket() {
    ws = new WebSocket(wsUrl);
    
    ws.onopen = () => {
        console.log('WebSocket connected');
    };
    
    ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        
        switch(data.type) {
            case 'user_joined':
                if (data.user_id !== currentUserId) {
                    await handleUserJoined(data);
                }
                break;
            
            case 'user_left':
                handleUserLeft(data);
                break;
            
            case 'offer':
                if (data.from_user_id !== currentUserId) {
                    await handleOffer(data);
                }
                break;
            
            case 'answer':
                await handleAnswer(data);
                break;
            
            case 'ice_candidate':
                if (data.from_user_id !== currentUserId) {
                    await handleIceCandidate(data);
                }
                break;
            
            case 'chat':
                handleChatMessage(data);
                break;
            
            case 'screen_share_started':
                if (data.user_id !== currentUserId) {
                    screenSharingUserId = data.user_id;
                    updateVideoLayout();
                }
                break;
            
            case 'screen_share_stopped':
                if (data.user_id === screenSharingUserId) {
                    screenSharingUserId = null;
                    updateVideoLayout();
                }
                break;
        }
    };
    
    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
    };
    
    ws.onclose = () => {
        console.log('WebSocket disconnected');
    };
}

async function handleUserJoined(data) {
    console.log('User joined:', data.username);
    
    // Add to participants list
    addParticipant(data.user_id, data.username);
    
    // Create peer connection and send offer
    const pc = createPeerConnection(data.user_id);
    
    // Add local stream tracks with optimized parameters
    localStream.getTracks().forEach(track => {
        const sender = pc.addTrack(track, localStream);
        
        // Set initial encoding parameters for low latency
        if (track.kind === 'video') {
            const params = sender.getParameters();
            if (!params.encodings) {
                params.encodings = [{}];
            }
            params.encodings[0].maxBitrate = 500000; // 500 Kbps for camera
            params.encodings[0].maxFramerate = 15;
            sender.setParameters(params);
        }
    });
    
    // Create offer with low latency settings
    const offer = await pc.createOffer({
        offerToReceiveAudio: true,
        offerToReceiveVideo: true
    });
    
    await pc.setLocalDescription(offer);
    
    ws.send(JSON.stringify({
        type: 'offer',
        offer: offer,
        to_user_id: data.user_id
    }));
}

function handleUserLeft(data) {
    console.log('User left:', data.username);
    
    // Check if they were screen sharing
    if (screenSharingUserId === data.user_id) {
        screenSharingUserId = null;
    }
    
    // Remove video element
    const videoEl = document.getElementById(`video-${data.user_id}`);
    if (videoEl) videoEl.remove();
    
    // Close peer connection
    if (peerConnections[data.user_id]) {
        peerConnections[data.user_id].close();
        delete peerConnections[data.user_id];
    }
    
    // Remove from participants
    delete participants[data.user_id];
    updateParticipantsList();
    updateVideoLayout();
}

async function handleOffer(data) {
    console.log('Received offer from:', data.from_username);
    
    const pc = createPeerConnection(data.from_user_id);
    
    // Add local stream tracks with optimized parameters
    localStream.getTracks().forEach(track => {
        const sender = pc.addTrack(track, localStream);
        
        // Set initial encoding parameters for low latency
        if (track.kind === 'video') {
            const params = sender.getParameters();
            if (!params.encodings) {
                params.encodings = [{}];
            }
            params.encodings[0].maxBitrate = 500000; // 500 Kbps for camera
            params.encodings[0].maxFramerate = 15;
            sender.setParameters(params);
        }
    });
    
    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
    
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    
    ws.send(JSON.stringify({
        type: 'answer',
        answer: answer,
        to_user_id: data.from_user_id
    }));
    
    // Add to participants
    addParticipant(data.from_user_id, data.from_username);
}

async function handleAnswer(data) {
    console.log('Received answer from:', data.from_username);
    
    const pc = peerConnections[data.from_user_id];
    if (pc) {
        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
    }
}

async function handleIceCandidate(data) {
    const pc = peerConnections[data.from_user_id];
    if (pc && data.candidate) {
        try {
            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
        } catch (error) {
            console.error('Error adding ICE candidate:', error);
        }
    }
}

function createPeerConnection(userId) {
    const pc = new RTCPeerConnection(rtcConfig);
    peerConnections[userId] = pc;
    
    // Handle ICE candidates
    pc.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'ice_candidate',
                candidate: event.candidate,
                to_user_id: userId
            }));
        }
    };
    
    // Handle incoming tracks
    pc.ontrack = (event) => {
        console.log('Received track from user:', userId);
        const remoteStream = event.streams[0];
        addVideoElement(userId, participants[userId] || 'User', remoteStream, false);
    };
    
    pc.onconnectionstatechange = () => {
        console.log('Connection state:', pc.connectionState);
        if (pc.connectionState === 'failed') {
            console.error('Connection failed, attempting restart');
            pc.restartIce();
        }
    };
    
    return pc;
}
function addVideoElement(userId, username, stream, isLocal) {
    let videoContainer = document.getElementById(`video-${userId}`);
    
    if (!videoContainer) {
        videoContainer = document.createElement('div');
        videoContainer.id = `video-${userId}`;
        videoContainer.className = 'video-box';
        videoContainer.dataset.userId = userId;
        
        const video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        video.playsInline = true;
        video.muted = isLocal;
        
        // Optimize video playback
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        
        const nameTag = document.createElement('div');
        nameTag.className = 'video-nametag';
        nameTag.textContent = isLocal ? 'You' : username;
        
        videoContainer.appendChild(video);
        videoContainer.appendChild(nameTag);
        
        document.getElementById('videoGridContainer').appendChild(videoContainer);
    } else {
        const video = videoContainer.querySelector('video');
        video.srcObject = stream;
    }
    
    // Use RAF for layout update
    requestAnimationFrame(() => {
        updateVideoLayout();
    });
}

// Debounce function for performance
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function updateVideoLayout() {
    const container = document.getElementById('videoGridContainer');
    if (!container) return;
    
    const videoBoxes = container.querySelectorAll('.video-box');
    const count = videoBoxes.length;
    
    // Remove all layout classes
    container.className = 'video-grid-container';
    
    // Simple layout based on participant count
    if (count === 1) {
        container.classList.add('single-view');
    } else {
        container.classList.add('grid-view', `count-${Math.min(count, 10)}`);
    }
    
    // Mark screen sharing video if active
    if (screenSharingUserId) {
        const screenShareBox = document.getElementById(`video-${screenSharingUserId}`);
        if (screenShareBox) {
            screenShareBox.classList.add('screen-share');
        }
    }
}

// Debounced version for frequent calls
const debouncedUpdateLayout = debounce(updateVideoLayout, 50);

function addParticipant(userId, username) {
    participants[userId] = username;
    updateParticipantsList();
}

function updateParticipantsList() {
    const count = Object.keys(participants).length + 1; // +1 for self
    document.getElementById('participantCount').textContent = count;
    
    const list = document.getElementById('participantsList');
    const existingItems = list.querySelectorAll('.participant-item:not(:first-child)');
    existingItems.forEach(item => item.remove());
    
    Object.entries(participants).forEach(([userId, username]) => {
        const item = document.createElement('div');
        item.className = 'participant-item';
        item.innerHTML = `
            <div class="participant-avatar">
                <img src="https://ui-avatars.com/api/?name=${username}&background=1877f2&color=fff" alt="${username}">
            </div>
            <div class="participant-info">
                <div class="participant-name">${username}</div>
            </div>
            <div class="participant-status">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>
            </div>
        `;
        list.appendChild(item);
    });
}

function toggleMic() {
    isMicOn = !isMicOn;
    localStream.getAudioTracks().forEach(track => {
        track.enabled = isMicOn;
    });
    
    const btn = document.getElementById('micBtn');
    btn.classList.toggle('off', !isMicOn);
    
    // Update button icon
    const micOnIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>';
    const micOffIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>';
    btn.innerHTML = isMicOn ? micOnIcon : micOffIcon;
    
    // Update status in sidebar
    const statusIcon = document.getElementById('localMicStatus');
    if (statusIcon) {
        statusIcon.outerHTML = isMicOn ? micOnIcon.replace('<svg', '<svg id="localMicStatus"') : micOffIcon.replace('<svg', '<svg id="localMicStatus"');
    }
}

function toggleCamera() {
    isCameraOn = !isCameraOn;
    localStream.getVideoTracks().forEach(track => {
        track.enabled = isCameraOn;
    });
    
    const btn = document.getElementById('camBtn');
    btn.classList.toggle('off', !isCameraOn);
    
    // Update button icon
    const camOnIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>';
    const camOffIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path></svg>';
    btn.innerHTML = isCameraOn ? camOnIcon : camOffIcon;
    
    // Update status in sidebar
    const statusIcon = document.getElementById('localCamStatus');
    if (statusIcon) {
        statusIcon.outerHTML = isCameraOn ? camOnIcon.replace('<svg', '<svg id="localCamStatus"') : camOffIcon.replace('<svg', '<svg id="localCamStatus"');
    }
}

async function toggleScreenShare() {
    // Check if someone else is already sharing
    if (!isScreenSharing && screenSharingUserId && screenSharingUserId !== currentUserId) {
        alert('Someone else is already sharing their screen. Only one person can share at a time.');
        return;
    }
    
    if (!isScreenSharing) {
        try {
            // Full quality screen sharing
            screenStream = await navigator.mediaDevices.getDisplayMedia({
                video: {
                    cursor: 'always',
                    frameRate: { ideal: 30, max: 60 },
                    width: { ideal: 1920, max: 3840 },
                    height: { ideal: 1080, max: 2160 }
                },
                audio: false
            });
            
            const videoTrack = screenStream.getVideoTracks()[0];
            
            // Get current settings
            const settings = videoTrack.getSettings();
            console.log('Screen share settings:', settings);
            
            // Replace video track in all peer connections with optimized parameters
            Object.values(peerConnections).forEach(pc => {
                const sender = pc.getSenders().find(s => s.track?.kind === 'video');
                if (sender) {
                    sender.replaceTrack(videoTrack).then(() => {
                        // Set high bitrate for screen sharing
                        const params = sender.getParameters();
                        if (!params.encodings) {
                            params.encodings = [{}];
                        }
                        
                        // High quality encoding for screen share
                        params.encodings[0].maxBitrate = 5000000; // 5 Mbps
                        params.encodings[0].maxFramerate = 60;
                        params.encodings[0].priority = 'high';
                        params.encodings[0].networkPriority = 'high';
                        
                        sender.setParameters(params).catch(err => {
                            console.error('Error setting parameters:', err);
                        });
                    }).catch(err => {
                        console.error('Error replacing track:', err);
                    });
                }
            });
            
            // Update local video
            const localVideo = document.querySelector(`#video-${currentUserId} video`);
            if (localVideo) {
                localVideo.srcObject = screenStream;
            }
            
            isScreenSharing = true;
            screenSharingUserId = currentUserId;
            
            const screenBtn = document.getElementById('screenBtn');
            if (screenBtn) {
                screenBtn.classList.add('active');
            }
            
            // Notify others about screen share
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'screen_share_started',
                    user_id: currentUserId
                }));
            }
            
            // Handle when user stops sharing via browser UI
            videoTrack.onended = () => {
                stopScreenShare();
            };
            
            console.log('Screen sharing started with full quality');
        } catch (error) {
            console.error('Error sharing screen:', error);
            if (error.name === 'NotAllowedError') {
                alert('Screen sharing permission denied.');
            } else if (error.name === 'NotFoundError') {
                alert('No screen available to share.');
            } else {
                alert('Failed to start screen sharing: ' + error.message);
            }
        }
    } else {
        stopScreenShare();
    }
}

function stopScreenShare() {
    console.log('Stopping screen share');
    
    if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
        screenStream = null;
    }
    
    const videoTrack = localStream.getVideoTracks()[0];
    
    // Replace back to camera in all peer connections with normal parameters
    Object.values(peerConnections).forEach(pc => {
        const sender = pc.getSenders().find(s => s.track?.kind === 'video');
        if (sender && videoTrack) {
            sender.replaceTrack(videoTrack).then(() => {
                // Reset to normal camera bitrate
                const params = sender.getParameters();
                if (params.encodings && params.encodings.length > 0) {
                    params.encodings[0].maxBitrate = 500000; // 500 Kbps for camera
                    params.encodings[0].maxFramerate = 15;
                    params.encodings[0].priority = 'medium';
                    params.encodings[0].networkPriority = 'medium';
                    
                    sender.setParameters(params).catch(err => {
                        console.error('Error resetting parameters:', err);
                    });
                }
            }).catch(err => {
                console.error('Error replacing track back to camera:', err);
            });
        }
    });
    
    // Update local video
    const localVideo = document.querySelector(`#video-${currentUserId} video`);
    if (localVideo && localStream) {
        localVideo.srcObject = localStream;
    }
    
    isScreenSharing = false;
    if (screenSharingUserId === currentUserId) {
        screenSharingUserId = null;
    }
    
    const screenBtn = document.getElementById('screenBtn');
    if (screenBtn) {
        screenBtn.classList.remove('active');
    }
    
    // Notify others
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'screen_share_stopped',
            user_id: currentUserId
        }));
    }
    
    console.log('Screen sharing stopped');
}

function toggleSidebar() {
    const sidebar = document.getElementById('meetSidebar');
    const isVisible = sidebar.style.display !== 'none';
    sidebar.style.display = isVisible ? 'none' : 'flex';
    
    // Adjust main container when sidebar opens/closes
    const mainContainer = document.getElementById('videoGridContainer');
    if (!isVisible) {
        mainContainer.style.marginRight = '360px';
    } else {
        mainContainer.style.marginRight = '0';
    }
    
    if (!isVisible && document.getElementById('chatPanel').classList.contains('active')) {
        unreadMessages = 0;
        updateChatBadge();
    }
}

function openSidebar(tab) {
    const sidebar = document.getElementById('meetSidebar');
    const isVisible = sidebar.style.display !== 'none';
    
    // If sidebar is closed, open it
    if (!isVisible) {
        sidebar.style.display = 'flex';
        const mainContainer = document.getElementById('videoGridContainer');
        mainContainer.style.marginRight = '360px';
    }
    
    // Switch to the requested tab
    switchSidebarTab(tab);
    
    // Clear chat badge if opening chat
    if (tab === 'chat') {
        unreadMessages = 0;
        updateChatBadge();
    }
}

function switchSidebarTab(tab) {
    document.querySelectorAll('.sidebar-tab').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.sidebar-panel').forEach(panel => panel.classList.remove('active'));
    
    // Find and activate the correct tab button
    const tabButtons = document.querySelectorAll('.sidebar-tab');
    tabButtons.forEach(btn => {
        if ((tab === 'people' && btn.textContent.includes('People')) ||
            (tab === 'chat' && btn.textContent.includes('Chat'))) {
            btn.classList.add('active');
        }
    });
    
    document.getElementById(tab + 'Panel').classList.add('active');
    
    if (tab === 'chat') {
        unreadMessages = 0;
        updateChatBadge();
    }
}

function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (message && ws) {
        ws.send(JSON.stringify({
            type: 'chat',
            message: message,
            timestamp: new Date().toISOString()
        }));
        input.value = '';
    }
}

function handleChatMessage(data) {
    const chatMessages = document.getElementById('chatMessages');
    const isOwn = data.user_id === currentUserId;
    
    const messageEl = document.createElement('div');
    messageEl.className = `chat-msg ${isOwn ? 'own' : ''}`;
    messageEl.innerHTML = `
        <div class="chat-msg-header">
            <strong>${data.username}</strong>
            <span class="chat-msg-time">${new Date(data.timestamp).toLocaleTimeString()}</span>
        </div>
        <div class="chat-msg-text">${data.message}</div>
    `;
    
    chatMessages.appendChild(messageEl);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Update badge if chat not visible
    if (!document.getElementById('chatPanel').classList.contains('active') && !isOwn) {
        unreadMessages++;
        updateChatBadge();
    }
}

function updateChatBadge() {
    const badge = document.getElementById('chatBadge');
    if (unreadMessages > 0) {
        badge.textContent = unreadMessages;
        badge.style.display = 'block';
    } else {
        badge.style.display = 'none';
    }
}

document.getElementById('chatInput')?.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendChatMessage();
});

function toggleSettings() {
    alert('Settings panel coming soon!');
}

function leaveMeeting() {
    const message = isHost ? 'End meeting for everyone?' : 'Leave this meeting?';
    if (confirm(message)) {
        // Stop all tracks
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        if (screenStream) {
            screenStream.getTracks().forEach(track => track.stop());
        }
        
        // Close all peer connections
        Object.values(peerConnections).forEach(pc => pc.close());
        
        // Close WebSocket
        if (ws) ws.close();
        
        // Redirect
        const url = isHost ? '/meetings/teacher/' : '/meetings/student/';
        window.location.href = url;
    }
}

let startTime = Date.now();
function startTimer() {
    setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        document.getElementById('meetTimer').textContent = `${minutes}:${seconds}`;
    }, 1000);
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }
    if (ws) ws.close();
});

// Initialize on load
window.addEventListener('load', init);
</script>
</body>
</html>
